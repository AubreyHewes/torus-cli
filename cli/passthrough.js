var _ = require('lodash');
var cmds = require('./lib/cmds');
var fs = require('fs');
var execSync = require('child_process').execSync;

var CATEGORIES = {
  set: 'SECRETS',
  unset: 'SECRETS',
  view: 'SECRETS',
  run: 'SECRETS',

  login: 'ACCOUNT',
  logout: 'ACCOUNT',
  prefs: 'ACCOUNT',
  signup: 'ACCOUNT',
  verify: 'ACCOUNT',

  allow: 'ACCESS CONTROL',
  deny: 'ACCESS CONTROL',
  policies: 'ACCESS CONTROL',

  link: 'CONTEXT',
  unlink: 'CONTEXT',
  status: 'CONTEXT',

  orgs: 'ORGANIZATIONS',
  invites: 'ORGANIZATIONS',
  keypairs: 'ORGANIZATIONS',
  envs: 'ORGANIZATIONS',
  projects: 'ORGANIZATIONS',
  services: 'ORGANIZATIONS',
  teams: 'ORGANIZATIONS'
};

// These toplevel commands become `list` subcommands of themselves. The toplevel
// command gets the provided usage string.
var REPLACEMENTS = {
  orgs: 'View and create organizations',
  invites: 'View and accept organization invites',
  keypairs: 'View and generate organization keypairs',
  envs: 'View and manipulate environments within an organization',
  projects: 'View and manipulate projects within an organization',
  services: 'View and manipulate services within an organization',
  teams: 'View and manipulate teams within an organization',
  policies: 'View and manipulate access control list policies',
  prefs: 'View and set preferences'
};

function mungeCmd(mungedCmds, cmd) {
  var name = cmd.subpath;
  var lookup = cmd.slug;

  if (REPLACEMENTS[cmd.slug]) {
    name = 'list';
    lookup = lookup + ':list';

    var replacement = {
      name: cmd.slug,
      usage: REPLACEMENTS[cmd.slug],
      subcmds: [],
      flags: [],
      skipExec: true
    };
    if (mungedCmds[cmd.slug]) {
      replacement.subcmds = mungedCmds[cmd.slug].subcmds;
    }

    mungedCmds[cmd.slug] = replacement;
  }

  var argsUsage = cmd.usage.slice(cmd.slug.length + 1);
  var newcmd = {
    name: name,
    usage: cmd.description,
    argsUsage: argsUsage,
    subcmds: [],
    flags: cmd.options,
    slug: cmd.slug
  };

  if (cmd.group && name !== cmd.group) {
    var group = mungedCmds[cmd.group] || { subcmds: [] };
    group.subcmds.push(newcmd);
    mungedCmds[cmd.group] = group;
  } else {
    mungedCmds[lookup] = newcmd;
  }
}

function dumpFlag(f, flag, indent) {
  var pad = _.repeat(' ', indent);

  var name = flag.long.slice(2) + ', ' + flag.short.slice(1);

  if (flag.bool) {
    f.write(pad + 'cli.BoolFlag{\n');
  } else {
    f.write(pad + 'cli.StringFlag{\n');
    if (flag.defaultValue) {
      f.write(pad + '    Value: "' + flag.defaultValue + '",\n');
    }
  }

  f.write(pad + '    Name: "' + name + '",\n');
  f.write(pad + '    Usage: "' + flag.description + '",\n');
  f.write(pad + '},\n');
}

function dumpCmd(f, cmd, indent) {
  var pad = _.repeat(' ', indent);
  f.write(pad + '{\n');
  f.write(pad + '    Name: "' + cmd.name + '",\n');
  f.write(pad + '    Usage: "' + cmd.usage + '",\n');

  if (cmd.argsUsage) {
    f.write(pad + '    ArgsUsage: "' + cmd.argsUsage + '",\n');
  }

  if (CATEGORIES[cmd.name]) {
    f.write(pad + '    Category: "' + CATEGORIES[cmd.name] + '",\n');
  }

  if (cmd.subcmds.length > 0) {
    f.write(pad + '    Subcommands: []cli.Command{\n');
    cmd.subcmds.forEach(function (sub) {
      dumpCmd(f, sub, indent + 8);
    });
    f.write(pad + '    },\n');
  }

  if (cmd.flags.length > 0) {
    f.write(pad + '    Flags: []cli.Flag{\n');
    cmd.flags.forEach(function (flag) {
      dumpFlag(f, flag, indent + 8);
    });
    f.write(pad + '    },\n');
  }

  if (!cmd.skipExec) {
    var slugLen = 1 + cmd.slug.split(':').length;

    f.write(pad + '    Action: func(ctx *cli.Context) error {\n' +
            pad + '        return passthrough(ctx, ' + slugLen + ', "' + cmd.slug + '")\n' +
            pad + '    },\n');
  }

  f.write(pad + '},\n');
}

cmds.get().then(function (cmdList) {
  var mungedCmds = {};
  cmdList.forEach(function (cmd) {
    mungeCmd(mungedCmds, cmd);
  });

  var f = fs.createWriteStream('passthrough.go');
  f.write('// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!\n');
  f.write('package main\n');
  f.write('import "github.com/urfave/cli"\n');
  f.write('\n');
  f.write('var passthroughs = []cli.Command{\n');

  _.forEach(mungedCmds, function (cmd) {
    dumpCmd(f, cmd, 4);
  });

  f.write('}\n');
  f.end(null, null, function () {
    execSync('gofmt -w passthrough.go');
  });
});
